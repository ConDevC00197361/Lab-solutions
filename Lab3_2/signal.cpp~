/*!
 * \author Zoltan Fuzesi - C00197361
 * \version 1.0
 * \date 02/10/2017
 *
 * \copyright GNU Public License
 *
 * \mainpage Lab 3
 * \section name_sec Software Engineering
 * Lab 3, ConDev - Joseph Kehoe
 * \subsection info_sec Lab 3 - Description
 * The main method creates fived threads and four of them will call the mutexOne and the mutexTwo functions.#
 * In those two functions each thread will goes through in the loop ten times and increase the shared variable
 * value by one. The last thread only will call the printShared Variable function, which is displaying the 
 * shared variable value changed by the threads. The size of the loop can be changed in the mutex functions
 * and that will increase of decrease the shared variable value.
 * Debug function added to the makefile. to use debugger: 
 * 1. open terminal
 * 2. navigate to the folder where mutex lab is created
 * 3. Type in : gdb mutex  - to start the debugger function.
 * The Makefile runs the Doxygen to generate the documentation when the project build  
 *
 */

#include "Semaphore.h"
#include <iostream>
#include <thread>
#include <chrono>



/*!
 * \brief Description of the void mutexOne function
 * \param theSemaphore is in the parameter list type of thread
 * \details MutexOne function.
 *  and try to increase the value of the shared variable.
 */
void mutexOne(std::shared_ptr<Semaphore> theSemaphore, int& x)
{

  std::cout << "mutex one method " << '\n';
 // for (int i = 0; i < 10; i++)
 // {
   // std::cout << "Mutex one loop " << i << '\n';

    theSemaphore->Wait();
    x = x + 1;
    std::cout << "Mutex count " << count << '\n';
    theSemaphore->Signal();
 // }
}


/*!
 * \brief Description of the void mutexTwo function
 * \param theSemaphore is in the parameter list type of thread
 * \details MutexTwo function.
 *  and try to increase the value of the shared variable.
 */
void mutexTwo(std::shared_ptr<Semaphore> theSemaphore, int& x)
{

   std::cout << "mutex two method " << '\n';
 // for (int i = 0; i < 10; i++)
 // {
   //  std::cout << "Mutex two loop " << i << '\n';

    theSemaphore->Wait();
    x = x + 1;
    std::cout << "Mutex count " << count << '\n';
    theSemaphore->Signal();
 // }
}




/*!
 * \brief Description of the main function
 * \param thread threadOne is the first thread
 * \param thread threadTwo is the second thread
 * \param thread threadThree is the third thread
 * \param thread threadFour is the fourth thread
 * \param thread threadFive is the fifth thread
 * \details Main function of mutex 
 *  The main method creates five threads and call the mutexOne & mutexTwo functions with the first four threads.
 *  Because the five threads or shared pointer is a vectore of Semaphores, they are an instances of same Vector object and 
 *  sharing the same meber variables. All the threads are calling the count function in the Semaphore class and increasing 
 *  the value to the shared variableb that is protected with mutex lock in the critical section.
 */
int main(void){

  int count = 0;
  std::thread threadOne, threadTwo;

   std::shared_ptr<Semaphore> sem( new Semaphore);
    std::cout << "Threads are created" << '\n';
   threadTwo=std::thread(mutexOne,sem,count);
   threadOne=std::thread(mutexTwo,sem,count);

  
  
  
  threadOne.join();
  threadTwo.join();

  std::cout << "All threads joined" << '\n';
  std::cout << "Count value is : " << count <<'\n';
  
  return 0;
  
}
